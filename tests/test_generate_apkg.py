#!/usr/bin/env python3
"""
Validate APKG deck format generated by scripts/generate-apkg.py.

Tests that the Python script correctly produces standard Anki APKG files
using the genanki library.
"""

import base64
import json
import os
import sqlite3
import subprocess
import tempfile
import zipfile
from io import BytesIO
from pathlib import Path


def run_generate_apkg(input_data: dict) -> dict:
    """
    Run the generate-apkg.py script with JSON input.

    Returns the JSON output from the script.
    """
    script_path = Path(__file__).parent.parent / 'scripts' / 'generate-apkg.py'

    result = subprocess.run(
        ['python3', str(script_path)],
        input=json.dumps(input_data),
        capture_output=True,
        text=True
    )

    # Script returns JSON even on error (with success: false)
    # Only raise if we can't parse the output
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError:
        raise RuntimeError(f"Script failed with no valid JSON: {result.stderr}")


def validate_apkg_file(apkg_path: str) -> dict:
    """
    Validate that an APKG file has the correct structure.

    Returns dict with:
        - valid: bool
        - errors: list of error messages
        - warnings: list of warning messages
        - stats: dict with card count, media count, etc.
    """
    errors = []
    warnings = []
    stats = {}

    if not os.path.exists(apkg_path):
        return {
            "valid": False,
            "errors": [f"APKG file not found: {apkg_path}"],
            "warnings": [],
            "stats": {}
        }

    try:
        with zipfile.ZipFile(apkg_path, 'r') as zf:
            namelist = zf.namelist()
            stats["files"] = namelist

            # APKG must contain collection.anki2 (SQLite database)
            if 'collection.anki2' not in namelist:
                errors.append("Missing collection.anki2 database file")
                return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}

            # Extract and validate database
            with tempfile.TemporaryDirectory() as tmpdir:
                db_path = os.path.join(tmpdir, 'collection.anki2')
                with open(db_path, 'wb') as f:
                    f.write(zf.read('collection.anki2'))

                # Connect to database and validate schema
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()

                # Check for required tables
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = {row[0] for row in cursor.fetchall()}

                required_tables = {'col', 'notes', 'cards', 'revlog', 'graves'}
                missing_tables = required_tables - tables
                if missing_tables:
                    errors.append(f"Missing required tables: {missing_tables}")

                # Get deck info
                cursor.execute("SELECT decks FROM col")
                decks_json = cursor.fetchone()[0]
                decks = json.loads(decks_json)
                stats["decks"] = list(decks.values())

                # Count notes and cards
                cursor.execute("SELECT COUNT(*) FROM notes")
                note_count = cursor.fetchone()[0]
                stats["note_count"] = note_count

                cursor.execute("SELECT COUNT(*) FROM cards")
                card_count = cursor.fetchone()[0]
                stats["card_count"] = card_count

                # Get media files referenced in notes
                cursor.execute("SELECT flds FROM notes")
                media_refs = set()
                for row in cursor.fetchall():
                    fields = row[0]
                    # Look for <img src="..."> tags
                    import re
                    for match in re.finditer(r'<img src="([^"]+)">', fields):
                        media_refs.add(match.group(1))

                stats["media_refs"] = list(media_refs)

                conn.close()

            # Count media files in ZIP
            media_files = [f for f in namelist if f != 'collection.anki2' and f != 'media']
            stats["media_files"] = media_files
            stats["media_count"] = len(media_files)

            # Validate media references match media files
            # genanki uses numeric filenames (0, 1, 2, etc.) in media file
            # Check if media file exists (it's a JSON mapping)
            if 'media' in namelist:
                media_json = json.loads(zf.read('media'))
                stats["media_mapping"] = media_json

                # Check that all referenced files exist in ZIP
                for filename in media_refs:
                    # Media mapping is {index: filename}, so check if filename is in values
                    if filename not in media_json.values():
                        # Also check if file exists with numeric name
                        found = False
                        for idx, mapped_name in media_json.items():
                            if mapped_name == filename and idx in namelist:
                                found = True
                                break
                        if not found:
                            warnings.append(f"Referenced media file not found in ZIP: {filename}")

    except zipfile.BadZipFile:
        errors.append("Invalid ZIP file")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}
    except sqlite3.DatabaseError as e:
        errors.append(f"Database error: {e}")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}
    except Exception as e:
        errors.append(f"Unexpected error: {e}")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}

    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
        "stats": stats
    }


# =============================================================================
# Pytest Tests
# =============================================================================

class TestGenerateAPKG:
    """Tests for generate-apkg.py script output."""

    def test_simple_image_card(self):
        """Test generating a single card with an image."""
        # Create minimal PNG (1x1 red pixel)
        png_data = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
            0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
            0x54, 0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0x3F,
            0x00, 0x05, 0xFE, 0x02, 0xFE, 0xDC, 0xCC, 0x59,
            0xE7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
            0x44, 0xAE, 0x42, 0x60, 0x82
        ])

        input_data = {
            "deckName": "Test Deck",
            "cards": [
                {
                    "word": "apple",
                    "description": "A red fruit",
                    "imageBase64": base64.b64encode(png_data).decode(),
                    "mimeType": "image/png"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True, f"Script should succeed: {result.get('error', '')}"
        assert result["cardCount"] == 1
        assert result["imageCardCount"] == 1
        assert result["textCardCount"] == 0
        assert result["failedCount"] == 0
        assert "deckId" in result
        assert "apkgPath" in result

        # Validate the generated APKG file
        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True, f"APKG should be valid: {validation['errors']}"
        assert validation["stats"]["card_count"] == 1
        assert validation["stats"]["note_count"] == 1

    def test_text_only_card(self):
        """Test generating a card without an image (text-only)."""
        input_data = {
            "deckName": "Vocabulary",
            "cards": [
                {
                    "word": "serendipity",
                    "description": "Finding something good without looking for it"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1
        assert result["imageCardCount"] == 0
        assert result["textCardCount"] == 1
        assert result["failedCount"] == 0

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True
        assert validation["stats"]["card_count"] == 1

    def test_multiple_cards(self):
        """Test generating a deck with multiple cards."""
        png_data = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
            0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
            0x54, 0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0x3F,
            0x00, 0x05, 0xFE, 0x02, 0xFE, 0xDC, 0xCC, 0x59,
            0xE7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
            0x44, 0xAE, 0x42, 0x60, 0x82
        ])

        input_data = {
            "deckName": "Multi-Card Test",
            "cards": [
                {
                    "word": "bed",
                    "description": "Furniture for sleeping",
                    "imageBase64": base64.b64encode(png_data).decode()
                },
                {
                    "word": "table",
                    "description": "Furniture with a flat top"
                },
                {
                    "word": "chair",
                    "description": "Furniture for sitting",
                    "imageBase64": base64.b64encode(png_data).decode()
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 3
        assert result["imageCardCount"] == 2
        assert result["textCardCount"] == 1

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True
        assert validation["stats"]["card_count"] == 3
        assert validation["stats"]["note_count"] == 3

    def test_html_escaping(self):
        """Test that HTML special characters are properly escaped."""
        input_data = {
            "deckName": "HTML Test",
            "cards": [
                {
                    "word": "<script>alert('XSS')</script>",
                    "description": "Dangerous & <unsafe> content"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1

        # Validate APKG was created
        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True

        # Check that HTML is escaped in database
        with zipfile.ZipFile(result["apkgPath"], 'r') as zf:
            with tempfile.TemporaryDirectory() as tmpdir:
                db_path = os.path.join(tmpdir, 'collection.anki2')
                with open(db_path, 'wb') as f:
                    f.write(zf.read('collection.anki2'))

                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT flds FROM notes")
                fields = cursor.fetchone()[0]
                conn.close()

                # HTML entities should be escaped
                assert "&lt;script&gt;" in fields or "alert" not in fields
                assert "&amp;" in fields or "Dangerous & " not in fields

    def test_no_cards(self):
        """Test that empty card list returns error."""
        input_data = {
            "deckName": "Empty Deck",
            "cards": []
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is False
        assert "error" in result

    def test_invalid_json(self):
        """Test that invalid JSON input is handled gracefully."""
        script_path = Path(__file__).parent.parent / 'scripts' / 'generate-apkg.py'

        result = subprocess.run(
            ['python3', str(script_path)],
            input="not valid json",
            capture_output=True,
            text=True
        )

        assert result.returncode == 1
        output = json.loads(result.stdout)
        assert output["success"] is False
        assert "JSON" in output["error"]

    def test_missing_word_field(self):
        """Test that cards without word field are skipped."""
        input_data = {
            "deckName": "Missing Word",
            "cards": [
                {"description": "No word field"},
                {"word": "valid", "description": "This one is OK"}
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1  # Only the valid card
        assert result["failedCount"] == 1  # One card failed

    def test_unicode_content(self):
        """Test that Unicode characters are preserved correctly."""
        input_data = {
            "deckName": "Unicode Test",
            "cards": [
                {"word": "cafÃ©", "description": "Coffee shop"},
                {"word": "æ—¥æœ¬èªž", "description": "Japanese language"},
                {"word": "emoji ðŸŽ‰", "description": "Party celebration"}
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 3

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True


class TestAPKGDownloadIDValidation:
    """Tests for download ID validation (security hardening)."""

    def test_normal_deck_id(self):
        """Test that normal UUID-based deck IDs work."""
        input_data = {
            "deckName": "Normal Deck",
            "cards": [{"word": "test", "description": "test"}]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        deck_id = result["deckId"]

        # UUID prefix should be alphanumeric with hyphens
        import re
        assert re.match(r'^[a-f0-9-]+$', deck_id), f"Deck ID should be alphanumeric: {deck_id}"

    def test_apkg_path_security(self):
        """Test that APKG path is in /tmp/anki-decks and not vulnerable to traversal."""
        input_data = {
            "deckName": "Security Test",
            "cards": [{"word": "test", "description": "test"}]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        apkg_path = result["apkgPath"]

        # Path must be within /tmp/anki-decks
        assert apkg_path.startswith('/var/lib/n8n/anki-decks/'), f"Path should be in /var/lib/n8n/anki-decks: {apkg_path}"

        # Path must not contain directory traversal
        assert '..' not in apkg_path, f"Path should not contain ..: {apkg_path}"

        # Filename should end with .apkg
        assert apkg_path.endswith('.apkg'), f"Path should end with .apkg: {apkg_path}"


# =============================================================================
# CLI Interface
# =============================================================================

if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        # Run basic self-test
        print("Running APKG generation self-test...")

        test_input = {
            "deckName": "Self-Test Deck",
            "cards": [
                {"word": "test", "description": "A test word"}
            ]
        }

        try:
            result = run_generate_apkg(test_input)
            print(f"âœ“ Script execution: success={result['success']}")

            if result["success"]:
                validation = validate_apkg_file(result["apkgPath"])
                print(f"âœ“ APKG validation: valid={validation['valid']}")
                print(f"  Stats: {validation['stats']}")

                if validation["errors"]:
                    print(f"  Errors: {validation['errors']}")
                if validation["warnings"]:
                    print(f"  Warnings: {validation['warnings']}")

                sys.exit(0 if validation["valid"] else 1)
            else:
                print(f"âœ— Script failed: {result.get('error', 'Unknown error')}")
                sys.exit(1)
        except Exception as e:
            print(f"âœ— Test failed: {e}")
            sys.exit(1)
    else:
        print("Usage: python test_generate_apkg.py [--test]")
        print("  --test: Run self-test")
        print("\nFor full test suite, run: pytest tests/test_generate_apkg.py -v")
