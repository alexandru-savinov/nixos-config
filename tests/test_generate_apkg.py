#!/usr/bin/env python3
"""
Validate APKG deck format generated by scripts/generate-apkg.py.

Tests that the Python script correctly produces standard Anki APKG files
using the genanki library.
"""

import base64
import json
import os
import sqlite3
import subprocess
import tempfile
import zipfile
from io import BytesIO
from pathlib import Path


def run_generate_apkg(input_data: dict) -> dict:
    """
    Run the generate-apkg.py script with JSON input.

    Returns the JSON output from the script.
    Uses a temporary directory for APKG output to avoid permission issues
    with the production /var/lib/n8n/anki-decks directory.
    """
    script_path = Path(__file__).parent.parent / 'scripts' / 'generate-apkg.py'

    # Use a writable temp dir instead of /var/lib/n8n/anki-decks
    apkg_dir = tempfile.mkdtemp(prefix='apkg-test-')
    env = os.environ.copy()
    env['APKG_OUTPUT_DIR'] = apkg_dir

    result = subprocess.run(
        ['python3', str(script_path)],
        input=json.dumps(input_data),
        capture_output=True,
        text=True,
        env=env,
    )

    # Script returns JSON even on error (with success: false)
    # Only raise if we can't parse the output
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError:
        raise RuntimeError(f"Script failed with no valid JSON: {result.stderr}")


def validate_apkg_file(apkg_path: str) -> dict:
    """
    Validate that an APKG file has the correct structure.

    Returns dict with:
        - valid: bool
        - errors: list of error messages
        - warnings: list of warning messages
        - stats: dict with card count, media count, etc.
    """
    errors = []
    warnings = []
    stats = {}

    if not os.path.exists(apkg_path):
        return {
            "valid": False,
            "errors": [f"APKG file not found: {apkg_path}"],
            "warnings": [],
            "stats": {}
        }

    try:
        with zipfile.ZipFile(apkg_path, 'r') as zf:
            namelist = zf.namelist()
            stats["files"] = namelist

            # APKG must contain collection.anki2 (SQLite database)
            if 'collection.anki2' not in namelist:
                errors.append("Missing collection.anki2 database file")
                return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}

            # Extract and validate database
            with tempfile.TemporaryDirectory() as tmpdir:
                db_path = os.path.join(tmpdir, 'collection.anki2')
                with open(db_path, 'wb') as f:
                    f.write(zf.read('collection.anki2'))

                # Connect to database and validate schema
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()

                # Check for required tables
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = {row[0] for row in cursor.fetchall()}

                required_tables = {'col', 'notes', 'cards', 'revlog', 'graves'}
                missing_tables = required_tables - tables
                if missing_tables:
                    errors.append(f"Missing required tables: {missing_tables}")

                # Get deck info
                cursor.execute("SELECT decks FROM col")
                decks_json = cursor.fetchone()[0]
                decks = json.loads(decks_json)
                stats["decks"] = list(decks.values())

                # Count notes and cards
                cursor.execute("SELECT COUNT(*) FROM notes")
                note_count = cursor.fetchone()[0]
                stats["note_count"] = note_count

                cursor.execute("SELECT COUNT(*) FROM cards")
                card_count = cursor.fetchone()[0]
                stats["card_count"] = card_count

                # Get media files referenced in notes
                cursor.execute("SELECT flds FROM notes")
                media_refs = set()
                for row in cursor.fetchall():
                    fields = row[0]
                    # Look for <img src="..."> tags
                    import re
                    for match in re.finditer(r'<img src="([^"]+)">', fields):
                        media_refs.add(match.group(1))

                stats["media_refs"] = list(media_refs)

                conn.close()

            # Count media files in ZIP
            media_files = [f for f in namelist if f != 'collection.anki2' and f != 'media']
            stats["media_files"] = media_files
            stats["media_count"] = len(media_files)

            # Validate media references match media files
            # genanki uses numeric filenames (0, 1, 2, etc.) in media file
            # Check if media file exists (it's a JSON mapping)
            if 'media' in namelist:
                media_json = json.loads(zf.read('media'))
                stats["media_mapping"] = media_json

                # Check that all referenced files exist in ZIP
                for filename in media_refs:
                    # Media mapping is {index: filename}, so check if filename is in values
                    if filename not in media_json.values():
                        # Also check if file exists with numeric name
                        found = False
                        for idx, mapped_name in media_json.items():
                            if mapped_name == filename and idx in namelist:
                                found = True
                                break
                        if not found:
                            warnings.append(f"Referenced media file not found in ZIP: {filename}")

    except zipfile.BadZipFile:
        errors.append("Invalid ZIP file")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}
    except sqlite3.DatabaseError as e:
        errors.append(f"Database error: {e}")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}
    except Exception as e:
        errors.append(f"Unexpected error: {e}")
        return {"valid": False, "errors": errors, "warnings": warnings, "stats": stats}

    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
        "stats": stats
    }


# =============================================================================
# Pytest Tests
# =============================================================================

class TestGenerateAPKG:
    """Tests for generate-apkg.py script output."""

    def test_simple_image_card(self):
        """Test generating a single card with an image."""
        # Create minimal PNG (1x1 red pixel)
        png_data = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
            0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
            0x54, 0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0x3F,
            0x00, 0x05, 0xFE, 0x02, 0xFE, 0xDC, 0xCC, 0x59,
            0xE7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
            0x44, 0xAE, 0x42, 0x60, 0x82
        ])

        input_data = {
            "deckName": "Test Deck",
            "cards": [
                {
                    "word": "apple",
                    "description": "A red fruit",
                    "imageBase64": base64.b64encode(png_data).decode(),
                    "mimeType": "image/png"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True, f"Script should succeed: {result.get('error', '')}"
        assert result["cardCount"] == 1
        assert result["imageCardCount"] == 1
        assert result["textCardCount"] == 0
        assert result["failedCount"] == 0
        assert "deckId" in result
        assert "apkgPath" in result

        # Validate the generated APKG file
        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True, f"APKG should be valid: {validation['errors']}"
        assert validation["stats"]["card_count"] == 1
        assert validation["stats"]["note_count"] == 1

    def test_text_only_card(self):
        """Test generating a card without an image (text-only)."""
        input_data = {
            "deckName": "Vocabulary",
            "cards": [
                {
                    "word": "serendipity",
                    "description": "Finding something good without looking for it"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1
        assert result["imageCardCount"] == 0
        assert result["textCardCount"] == 1
        assert result["failedCount"] == 0

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True
        assert validation["stats"]["card_count"] == 1

    def test_multiple_cards(self):
        """Test generating a deck with multiple cards."""
        png_data = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
            0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
            0x54, 0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0x3F,
            0x00, 0x05, 0xFE, 0x02, 0xFE, 0xDC, 0xCC, 0x59,
            0xE7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
            0x44, 0xAE, 0x42, 0x60, 0x82
        ])

        input_data = {
            "deckName": "Multi-Card Test",
            "cards": [
                {
                    "word": "bed",
                    "description": "Furniture for sleeping",
                    "imageBase64": base64.b64encode(png_data).decode()
                },
                {
                    "word": "table",
                    "description": "Furniture with a flat top"
                },
                {
                    "word": "chair",
                    "description": "Furniture for sitting",
                    "imageBase64": base64.b64encode(png_data).decode()
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 3
        assert result["imageCardCount"] == 2
        assert result["textCardCount"] == 1

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True
        assert validation["stats"]["card_count"] == 3
        assert validation["stats"]["note_count"] == 3

    def test_html_escaping(self):
        """Test that HTML special characters are properly escaped."""
        input_data = {
            "deckName": "HTML Test",
            "cards": [
                {
                    "word": "<script>alert('XSS')</script>",
                    "description": "Dangerous & <unsafe> content"
                }
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1

        # Validate APKG was created
        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True

        # Check that HTML is escaped in database
        with zipfile.ZipFile(result["apkgPath"], 'r') as zf:
            with tempfile.TemporaryDirectory() as tmpdir:
                db_path = os.path.join(tmpdir, 'collection.anki2')
                with open(db_path, 'wb') as f:
                    f.write(zf.read('collection.anki2'))

                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT flds FROM notes")
                fields = cursor.fetchone()[0]
                conn.close()

                # HTML entities should be escaped
                assert "&lt;script&gt;" in fields or "alert" not in fields
                assert "&amp;" in fields or "Dangerous & " not in fields

    def test_no_cards(self):
        """Test that empty card list returns error."""
        input_data = {
            "deckName": "Empty Deck",
            "cards": []
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is False
        assert "error" in result

    def test_invalid_json(self):
        """Test that invalid JSON input is handled gracefully."""
        script_path = Path(__file__).parent.parent / 'scripts' / 'generate-apkg.py'

        result = subprocess.run(
            ['python3', str(script_path)],
            input="not valid json",
            capture_output=True,
            text=True
        )

        assert result.returncode == 1
        output = json.loads(result.stdout)
        assert output["success"] is False
        assert "JSON" in output["error"]

    def test_missing_word_field(self):
        """Test that cards without word field are skipped."""
        input_data = {
            "deckName": "Missing Word",
            "cards": [
                {"description": "No word field"},
                {"word": "valid", "description": "This one is OK"}
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 1  # Only the valid card
        assert result["failedCount"] == 1  # One card failed

    def test_unicode_content(self):
        """Test that Unicode characters are preserved correctly."""
        input_data = {
            "deckName": "Unicode Test",
            "cards": [
                {"word": "cafÃ©", "description": "Coffee shop"},
                {"word": "æ—¥æœ¬èªž", "description": "Japanese language"},
                {"word": "emoji ðŸŽ‰", "description": "Party celebration"}
            ]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        assert result["cardCount"] == 3

        validation = validate_apkg_file(result["apkgPath"])
        assert validation["valid"] is True


def _make_png(width, height):
    """Create a PNG image of the given dimensions and return its bytes."""
    from PIL import Image
    from io import BytesIO
    img = Image.new('RGB', (width, height), color=(255, 0, 0))
    buf = BytesIO()
    img.save(buf, format='PNG')
    return buf.getvalue()


def _extract_image_dimensions(apkg_path):
    """Extract the first image from an APKG and return its (width, height)."""
    from PIL import Image
    from io import BytesIO
    with zipfile.ZipFile(apkg_path, 'r') as zf:
        media_json = json.loads(zf.read('media'))
        for idx, filename in media_json.items():
            if filename.startswith('img_'):
                img_data = zf.read(idx)
                img = Image.open(BytesIO(img_data))
                return img.size
    return None


class TestImageCompression:
    """Tests for image compression in generate-apkg.py."""

    def test_large_image_gets_resized(self):
        """A 1024x1024 image should be resized to 512x512."""
        png_data = _make_png(1024, 1024)

        input_data = {
            "deckName": "Compression Test",
            "cards": [{
                "word": "big",
                "description": "A large image",
                "imageBase64": base64.b64encode(png_data).decode(),
                "mimeType": "image/png"
            }]
        }

        result = run_generate_apkg(input_data)
        assert result["success"] is True

        dims = _extract_image_dimensions(result["apkgPath"])
        assert dims is not None, "Should have an image in the APKG"
        assert dims == (512, 512), f"Expected 512x512, got {dims[0]}x{dims[1]}"

    def test_small_image_unchanged(self):
        """A 256x256 image should not be resized."""
        png_data = _make_png(256, 256)

        input_data = {
            "deckName": "No Resize Test",
            "cards": [{
                "word": "small",
                "description": "A small image",
                "imageBase64": base64.b64encode(png_data).decode(),
                "mimeType": "image/png"
            }]
        }

        result = run_generate_apkg(input_data)
        assert result["success"] is True

        dims = _extract_image_dimensions(result["apkgPath"])
        assert dims is not None
        assert dims == (256, 256), f"Expected 256x256, got {dims[0]}x{dims[1]}"

    def test_non_square_image_maintains_ratio(self):
        """A 1024x768 image should resize to 512x384 (maintaining aspect ratio)."""
        png_data = _make_png(1024, 768)

        input_data = {
            "deckName": "Aspect Ratio Test",
            "cards": [{
                "word": "wide",
                "description": "A wide image",
                "imageBase64": base64.b64encode(png_data).decode(),
                "mimeType": "image/png"
            }]
        }

        result = run_generate_apkg(input_data)
        assert result["success"] is True

        dims = _extract_image_dimensions(result["apkgPath"])
        assert dims is not None
        assert dims == (512, 384), f"Expected 512x384, got {dims[0]}x{dims[1]}"

    def test_compressed_image_bytes_are_smaller(self):
        """The image inside the APKG should be smaller after compression."""
        png_data = _make_png(1024, 1024)
        original_size = len(png_data)

        input_data = {
            "deckName": "Size Test",
            "cards": [{
                "word": "compress",
                "description": "Test compression",
                "imageBase64": base64.b64encode(png_data).decode(),
                "mimeType": "image/png"
            }]
        }

        result = run_generate_apkg(input_data)
        assert result["success"] is True

        # Extract the image from APKG and compare raw bytes
        with zipfile.ZipFile(result["apkgPath"], 'r') as zf:
            media_json = json.loads(zf.read('media'))
            for idx, filename in media_json.items():
                if filename.startswith('img_'):
                    compressed_size = len(zf.read(idx))
                    assert compressed_size <= original_size, \
                        f"Compressed image ({compressed_size}B) should be <= original ({original_size}B)"
                    break


class TestAPKGDownloadIDValidation:
    """Tests for download ID validation (security hardening)."""

    def test_normal_deck_id(self):
        """Test that normal UUID-based deck IDs work."""
        input_data = {
            "deckName": "Normal Deck",
            "cards": [{"word": "test", "description": "test"}]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        deck_id = result["deckId"]

        # UUID prefix should be alphanumeric with hyphens
        import re
        assert re.match(r'^[a-f0-9-]+$', deck_id), f"Deck ID should be alphanumeric: {deck_id}"

    def test_apkg_path_security(self):
        """Test that APKG path is in the output dir and not vulnerable to traversal."""
        input_data = {
            "deckName": "Security Test",
            "cards": [{"word": "test", "description": "test"}]
        }

        result = run_generate_apkg(input_data)

        assert result["success"] is True
        apkg_path = result["apkgPath"]

        # Path must be within its parent directory (the configured output dir)
        # In tests this is a temp dir; in production it's /var/lib/n8n/anki-decks
        parent_dir = os.path.dirname(apkg_path)
        assert os.path.isabs(apkg_path), f"Path should be absolute: {apkg_path}"
        assert os.path.basename(apkg_path) == os.path.basename(apkg_path).strip('/'), \
            f"Filename should not contain slashes: {apkg_path}"

        # Path must not contain directory traversal
        assert '..' not in apkg_path, f"Path should not contain ..: {apkg_path}"

        # Filename should be <uuid>.apkg with no extra path components
        assert apkg_path.endswith('.apkg'), f"Path should end with .apkg: {apkg_path}"
        assert apkg_path == os.path.join(parent_dir, os.path.basename(apkg_path)), \
            f"Path should be a direct child of output dir: {apkg_path}"


# =============================================================================
# CLI Interface
# =============================================================================

if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        # Run basic self-test
        print("Running APKG generation self-test...")

        test_input = {
            "deckName": "Self-Test Deck",
            "cards": [
                {"word": "test", "description": "A test word"}
            ]
        }

        try:
            result = run_generate_apkg(test_input)
            print(f"âœ“ Script execution: success={result['success']}")

            if result["success"]:
                validation = validate_apkg_file(result["apkgPath"])
                print(f"âœ“ APKG validation: valid={validation['valid']}")
                print(f"  Stats: {validation['stats']}")

                if validation["errors"]:
                    print(f"  Errors: {validation['errors']}")
                if validation["warnings"]:
                    print(f"  Warnings: {validation['warnings']}")

                sys.exit(0 if validation["valid"] else 1)
            else:
                print(f"âœ— Script failed: {result.get('error', 'Unknown error')}")
                sys.exit(1)
        except Exception as e:
            print(f"âœ— Test failed: {e}")
            sys.exit(1)
    else:
        print("Usage: python test_generate_apkg.py [--test]")
        print("  --test: Run self-test")
        print("\nFor full test suite, run: pytest tests/test_generate_apkg.py -v")
