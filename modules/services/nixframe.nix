# NixFrame — Digital Photo Frame for Raspberry Pi 5
#
# Displays a rotating slideshow on HDMI-A-2 with a clock/date sidebar.
# Photos are uploaded via n8n webhook (mobile-friendly web form).
#
# Components:
#   getty auto-login (VT 7) → Sway compositor → imv slideshow + Eww sidebar
#   n8n webhooks → validate → convert → atomic save → systemd.paths reload
#
# Display isolation:
#   VT 1: root auto-login + btop (unchanged, HDMI-A-1)
#   VT 7: nixframe auto-login + Sway (HDMI-A-2 only)
#   Sway takes GPU control when VT 7 is active, returns it on VT switch.
#
# Usage in host configuration:
#   services.nixframe.enable = true;
#   # All defaults match RPi5 + Samsung 4K TV on HDMI-A-2
#
# Access upload form via Tailscale HTTPS:
#   https://rpi5.tail4249a9.ts.net:5678/webhook/nixframe-ui

{ config, pkgs, lib, ... }:

with lib;

let
  cfg = config.services.nixframe;

  # Placeholder SVG for when no photos exist yet
  placeholderImage = pkgs.writeText "nixframe-placeholder.svg" ''
    <svg xmlns="http://www.w3.org/2000/svg" width="1920" height="1080" viewBox="0 0 1920 1080">
      <rect width="1920" height="1080" fill="#1a1a2e"/>
      <text x="960" y="480" text-anchor="middle" font-family="sans-serif"
            font-size="64" fill="#e0e0e0">NixFrame</text>
      <text x="960" y="560" text-anchor="middle" font-family="sans-serif"
            font-size="32" fill="#888">Upload photos to get started</text>
      <text x="960" y="620" text-anchor="middle" font-family="monospace"
            font-size="24" fill="#667eea">https://rpi5.tail4249a9.ts.net:5678/webhook/nixframe-ui</text>
    </svg>
  '';

  # Convert placeholder SVG to PNG at build time
  placeholderPng = pkgs.runCommand "nixframe-placeholder.png" {
    nativeBuildInputs = [ pkgs.imagemagick ];
  } ''
    convert ${placeholderImage} -resize 1920x1080 $out
  '';

  # Eww widget definition (yuck)
  ewwYuck = pkgs.writeText "eww-nixframe.yuck" ''
    (defpoll clock-time :interval "1s" "date +%H:%M")
    (defpoll clock-date :interval "60s" "date '+%A, %B %-d'")

    (defwindow sidebar
      :monitor 0
      :geometry (geometry :width "${toString cfg.sidebarWidth}px" :height "100%" :anchor "center right")
      :stacking "fg"
      :exclusive true
      :focusable false
      (box :class "sidebar" :orientation "v" :valign "center" :space-evenly false :spacing 20
        (label :class "clock" :text clock-time)
        (label :class "date"  :text clock-date)))
  '';

  # Eww styling (scss)
  ewwScss = pkgs.writeText "eww-nixframe.scss" ''
    * {
      all: unset;
      font-family: "Noto Sans", sans-serif;
    }

    .sidebar {
      background-color: rgba(0, 0, 0, 0.75);
      padding: 40px;
    }

    .clock {
      font-size: 200px;
      font-weight: 700;
      color: #ffffff;
    }

    .date {
      font-size: 60px;
      font-weight: 400;
      color: #cccccc;
    }
  '';

  # imv wrapper script — starts slideshow with restart-on-crash
  imvStart = pkgs.writeShellScript "nixframe-imv-start" ''
    PHOTO_DIR="${cfg.photoDir}"

    # Ensure placeholder exists if no photos uploaded yet
    if [ -z "$(ls -A "$PHOTO_DIR"/*.jpg "$PHOTO_DIR"/*.jpeg "$PHOTO_DIR"/*.png "$PHOTO_DIR"/*.webp 2>/dev/null)" ]; then
      cp ${placeholderPng} "$PHOTO_DIR/000-placeholder.png"
    fi

    # Start imv as tiled window (NOT fullscreen — respects Eww exclusive zone)
    while true; do
      ${pkgs.imv}/bin/imv -t ${toString cfg.slideshowInterval} "$PHOTO_DIR" || true
      sleep 5
    done
  '';

  # Eww wrapper script — starts daemon then opens sidebar
  ewwStart = pkgs.writeShellScript "nixframe-eww-start" ''
    # Setup eww config directory
    mkdir -p "$HOME/.config/eww"
    ln -sf ${ewwYuck} "$HOME/.config/eww/eww.yuck"
    ln -sf ${ewwScss} "$HOME/.config/eww/eww.scss"

    # Start eww daemon, then open sidebar
    while true; do
      ${pkgs.eww}/bin/eww daemon &
      sleep 2
      ${pkgs.eww}/bin/eww open sidebar
      # Wait for eww daemon to exit (crash recovery)
      wait
      sleep 5
    done
  '';

  # Generated Sway config
  swayConfig = pkgs.writeText "sway-nixframe.conf" ''
    # NixFrame Sway Configuration (generated by NixOS module)

    # Target HDMI-A-2 for photo frame display
    output ${cfg.output} {
      resolution ${cfg.resolution}
      bg #000000 solid_color
    }

    # Window styling — no borders for clean photo display
    default_border none
    default_floating_border none
    bar { mode invisible }

    # Disable DPMS screen blanking — always-on display
    output * dpms on
    exec swaymsg output '*' dpms on

    # imv: tiled window, fills remaining space after Eww exclusive zone
    for_window [app_id="imv"] border none

    # Launch photo slideshow and sidebar
    exec ${imvStart}
    exec ${ewwStart}

    # Emergency exit (via SSH: swaymsg exit)
    bindsym Ctrl+Shift+q exit
  '';
in
{
  options.services.nixframe = {
    enable = mkEnableOption "NixFrame digital photo frame";

    photoDir = mkOption {
      type = types.path;
      default = "/var/lib/nixframe/photos";
      description = "Directory for photo storage.";
    };

    slideshowInterval = mkOption {
      type = types.int;
      default = 60;
      description = "Seconds between photo transitions.";
    };

    output = mkOption {
      type = types.str;
      default = "HDMI-A-2";
      description = "Sway output name for the display.";
    };

    resolution = mkOption {
      type = types.str;
      default = "3840x2160";
      description = "Display resolution (Sway picks best refresh rate).";
    };

    sidebarWidth = mkOption {
      type = types.int;
      default = 800;
      description = "Width of the Eww clock/date sidebar in pixels.";
    };

    vt = mkOption {
      type = types.int;
      default = 7;
      description = "Virtual terminal for nixframe auto-login (avoids conflict with TTY1 btop).";
    };
  };

  config = mkIf cfg.enable {
    # ──────────────────────────────────────────────────────────────
    # User and group
    # ──────────────────────────────────────────────────────────────
    users.users.nixframe = {
      isNormalUser = true;
      group = "nixframe";
      extraGroups = [ "video" ]; # DRM access for GPU rendering
      home = "/var/lib/nixframe";
      createHome = true;
      description = "NixFrame photo frame display user";
    };

    users.groups.nixframe = { };

    # Add n8n user to nixframe group so n8n can write photos
    users.users.n8n.extraGroups = mkIf config.services.n8n-tailscale.enable [ "nixframe" ];

    # ──────────────────────────────────────────────────────────────
    # Directories
    # ──────────────────────────────────────────────────────────────
    systemd.tmpfiles.rules = [
      # Home dir needs group traverse (0750) so n8n can reach photos/
      "d /var/lib/nixframe 0750 nixframe nixframe -"
      "d ${cfg.photoDir} 0775 nixframe nixframe -"
      # Seed the trigger file so systemd.paths has something to watch on first boot
      "f ${cfg.photoDir}/.trigger 0664 nixframe nixframe -"
    ];

    # ──────────────────────────────────────────────────────────────
    # GPU / Display prerequisites
    # ──────────────────────────────────────────────────────────────
    hardware.graphics.enable = true;

    # Sway PAM/polkit/dbus integration (provides security.pam.services.sway)
    programs.sway.enable = true;

    # Fonts for Eww sidebar
    fonts.packages = [ pkgs.noto-fonts ];

    # ──────────────────────────────────────────────────────────────
    # Auto-login on VT 7 — mirrors the btop-on-VT1 pattern
    # ──────────────────────────────────────────────────────────────
    # getty auto-login for nixframe user on tty7
    systemd.services."getty@tty${toString cfg.vt}" = {
      overrideStrategy = "asDropin";
      serviceConfig.ExecStart = [
        "" # Clear the default ExecStart
        "@${pkgs.util-linux}/sbin/agetty agetty --autologin nixframe --noclear %I $TERM"
      ];
    };

    # Auto-start Sway when nixframe logs into tty7
    # Same pattern as btop auto-start on tty1 for root
    programs.bash.interactiveShellInit = ''
      if [[ "$(tty)" == "/dev/tty${toString cfg.vt}" ]] && [[ "$(whoami)" == "nixframe" ]] && [[ -z "$NIXFRAME_RUNNING" ]]; then
        export NIXFRAME_RUNNING=1
        exec ${pkgs.sway}/bin/sway --config ${swayConfig}
      fi
    '';

    # ──────────────────────────────────────────────────────────────
    # Photo watcher — reload imv when photos change
    # ──────────────────────────────────────────────────────────────
    systemd.paths.nixframe-photo-watcher = {
      description = "Watch NixFrame photo directory for changes";
      wantedBy = [ "multi-user.target" ];
      pathConfig = {
        # Watch a trigger file instead of the directory itself.
        # systemd PathModified uses inotify IN_MODIFY, but atomic rename()
        # emits IN_MOVED_TO which isn't reliably caught (systemd bug #20934).
        # The n8n upload workflow writes this file after each photo save.
        PathModified = "${cfg.photoDir}/.trigger";
        Unit = "nixframe-photo-refresh.service";
      };
    };

    systemd.services.nixframe-photo-refresh = {
      description = "Reload imv after photo directory changes";
      serviceConfig = {
        Type = "oneshot";
        # Run as nixframe user so imv-msg can find the IPC socket
        # at $XDG_RUNTIME_DIR/imv-$PID.sock
        User = "nixframe";
        Group = "nixframe";
        ExecStart = pkgs.writeShellScript "nixframe-refresh-imv" ''
          export XDG_RUNTIME_DIR="/run/user/$(id -u)"
          # Use newest imv PID (pgrep -n) to avoid stale processes
          IMV_PID=$(${pkgs.procps}/bin/pgrep -n -u nixframe imv || true)
          if [ -n "$IMV_PID" ]; then
            ${pkgs.imv}/bin/imv-msg "$IMV_PID" close all
            ${pkgs.imv}/bin/imv-msg "$IMV_PID" open "${cfg.photoDir}"
          fi
        '';
      };
    };

    # ──────────────────────────────────────────────────────────────
    # Photo cleanup timer — remove orphaned temp files
    # ──────────────────────────────────────────────────────────────
    systemd.timers.nixframe-cleanup = {
      description = "Clean up NixFrame temporary files";
      wantedBy = [ "timers.target" ];
      timerConfig = {
        OnCalendar = "daily";
        Persistent = true;
      };
    };

    systemd.services.nixframe-cleanup = {
      description = "Remove orphaned NixFrame temp files";
      serviceConfig = {
        Type = "oneshot";
        User = "nixframe";
        Group = "nixframe";
      };
      script = ''
        PHOTO_DIR="${cfg.photoDir}"
        if [ -d "$PHOTO_DIR" ]; then
          # Remove temp files older than 1 hour (failed uploads)
          ${pkgs.findutils}/bin/find "$PHOTO_DIR" -name '.tmp-*' -mmin +60 -delete 2>/dev/null || true
          echo "NixFrame cleanup complete"
        fi
      '';
    };

    # ──────────────────────────────────────────────────────────────
    # Packages
    # ──────────────────────────────────────────────────────────────
    environment.systemPackages = with pkgs; [
      imv # Photo viewer
      eww # Widget sidebar
      sway # Compositor (for swaymsg CLI from SSH)
      imagemagick # HEIC conversion + EXIF orient (used by n8n workflow)
    ];
  };
}
