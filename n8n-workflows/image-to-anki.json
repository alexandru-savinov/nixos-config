{
  "id": "image-to-anki",
  "name": "Image to Anki Deck (APKG)",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 300],
      "webhookId": "image-to-anki",
      "parameters": {
        "path": "image-to-anki",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "normalize-input",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 300],
      "parameters": {
        "jsCode": "// Normalize and validate input - returns error JSON if invalid\nconst body = $input.first().json.body || {};\n\nif (body.imageUrl && typeof body.imageUrl === 'string' && body.imageUrl.length > 0) {\n  return [{ json: { ...($input.first().json), imageSource: body.imageUrl, inputType: 'url', isValid: true } }];\n}\n\nif (body.imageData && typeof body.imageData === 'string' && body.imageData.length > 0) {\n  let data = body.imageData;\n  if (!data.startsWith('data:')) {\n    data = 'data:image/png;base64,' + data;\n  }\n  return [{ json: { ...($input.first().json), imageSource: data, inputType: 'base64', isValid: true } }];\n}\n\n// Invalid - return error marker\nreturn [{ json: { isValid: false, error: 'Missing image. Send POST with {\"imageUrl\": \"...\"} or {\"imageData\": \"...\"}' } }];\n"
      }
    },
    {
      "id": "check-valid",
      "name": "Check Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [500, 300],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose" },
          "conditions": [
            {
              "id": "is-valid",
              "leftValue": "={{ $json.isValid }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [700, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.error }) }}",
        "options": { "responseCode": 400 }
      }
    },
    {
      "id": "vision-extract",
      "name": "Extract Vocabulary (Vision)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [700, 300],
      "onError": "continueErrorOutput",
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}" },
            { "name": "HTTP-Referer", "value": "https://rpi5.tail4249a9.ts.net" },
            { "name": "X-Title", "value": "Image-to-Anki" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'google/gemini-2.5-flash', max_tokens: 4096, zdr: true, messages: [{ role: 'user', content: [{ type: 'text', text: 'TASK: Extract EVERY vocabulary item from this educational infographic. Be EXHAUSTIVE - these images often contain 10-30+ items.\\n\\nINSTRUCTIONS:\\n1. Scan the ENTIRE image systematically\\n2. Include EVERY labeled word/item\\n3. Count and verify you captured everything\\n\\nOUTPUT: Return ONLY a JSON array: [{\"word\": \"...\", \"description\": \"3-5 words for illustration\"}]\\n\\nNo markdown, no code blocks.' }, { type: 'image_url', image_url: { url: $json.imageSource } }] }] }) }}",
        "options": { "timeout": 120000 }
      }
    },
    {
      "id": "vision-error-response",
      "name": "Vision Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'Vision API failed: ' + ($json.error?.message || $json.message || 'Unknown error'), details: $json.error?.description || $json.statusCode || null }) }}",
        "options": { "responseCode": 502 }
      }
    },
    {
      "id": "parse-vocabulary",
      "name": "Parse Vocabulary JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300],
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst imageSource = $('Normalize Input').first().json.imageSource;\nconst inputType = $('Normalize Input').first().json.inputType;\n\nconst content = response.choices?.[0]?.message?.content || '';\nif (!content) {\n  return [{ json: { parseError: 'No content in LLM response' } }];\n}\n\nlet jsonStr = content.trim();\nif (jsonStr.includes('```')) {\n  const start = jsonStr.indexOf('[');\n  const end = jsonStr.lastIndexOf(']') + 1;\n  if (start >= 0 && end > start) jsonStr = jsonStr.substring(start, end);\n}\n\nlet vocabulary;\ntry {\n  vocabulary = JSON.parse(jsonStr);\n} catch (e) {\n  return [{ json: { parseError: 'Invalid JSON: ' + e.message, rawContent: jsonStr.substring(0, 200) } }];\n}\n\nif (!Array.isArray(vocabulary) || vocabulary.length === 0) {\n  return [{ json: { parseError: 'No vocabulary found', rawContent: jsonStr.substring(0, 200) } }];\n}\n\nreturn vocabulary.map((item, index) => ({\n  json: { index, word: item.word, description: item.description, imageSource, inputType, totalItems: vocabulary.length }\n}));\n"
      }
    },
    {
      "id": "check-parse-error",
      "name": "Check Parse Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1100, 300],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose" },
          "conditions": [
            {
              "id": "no-error",
              "leftValue": "={{ $json.parseError }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notExists", "singleValue": true }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "parse-error-response",
      "name": "Parse Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1300, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.parseError, rawContent: $json.rawContent }) }}",
        "options": { "responseCode": 500 }
      }
    },
    {
      "id": "loop-items",
      "name": "Loop Over Items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1300, 300],
      "parameters": { "batchSize": 5, "options": {} }
    },
    {
      "id": "generate-image",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 300],
      "onError": "continueErrorOutput",
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}" },
            { "name": "HTTP-Referer", "value": "https://rpi5.tail4249a9.ts.net" },
            { "name": "X-Title", "value": "Image-to-Anki" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'bytedance-seed/seedream-4.5', modalities: ['text', 'image'], zdr: false, messages: [{ role: 'user', content: 'Generate a simple illustration for flashcard: ' + $json.word + ' (' + $json.description + '). Style: flat, minimal, white background, no text.' }] }) }}",
        "options": { "timeout": 120000 }
      }
    },
    {
      "id": "handle-image-error",
      "name": "Handle Image Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 500],
      "parameters": {
        "jsCode": "// Handle HTTP errors from image generation gracefully\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\nconst errorInfo = $input.first().json;\nconst errorMsg = errorInfo.error?.message || errorInfo.message || 'Image generation failed';\nreturn [{ json: { index, word, description, error: errorMsg, imageBase64: null, imageHash: null } }];\n"
      }
    },
    {
      "id": "extract-image-data",
      "name": "Extract Image Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 300],
      "parameters": {
        "jsCode": "const crypto = require('crypto');\nconst response = $input.first().json;\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\n\ntry {\n  const message = response.choices?.[0]?.message;\n  let base64Data = null, mimeType = 'image/png';\n\n  if (message?.images?.[0]) {\n    const img = message.images[0];\n    const url = img.image_url?.url || img.url || img;\n    if (typeof url === 'string' && url.includes('base64,')) {\n      base64Data = url.split('base64,')[1];\n      if (url.includes('jpeg')) mimeType = 'image/jpeg';\n    }\n  }\n\n  if (!base64Data && message?.content) {\n    const m = message.content.match(/data:image\\/([^;]+);base64,([A-Za-z0-9+/=]+)/);\n    if (m) { mimeType = 'image/' + m[1]; base64Data = m[2]; }\n  }\n\n  if (!base64Data) throw new Error('No image');\n\n  const bytes = Buffer.from(base64Data, 'base64');\n  const hash = crypto.createHash('sha256').update(bytes).digest('hex');\n  return [{ json: { index, word, description, imageBase64: base64Data, imageHash: hash, mimeType, imageSizeBytes: bytes.length } }];\n} catch (e) {\n  return [{ json: { index, word, description, error: e.message, imageBase64: null, imageHash: null } }];\n}\n"
      }
    },
    {
      "id": "wait-rate-limit",
      "name": "Wait (Rate Limit)",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1900, 300],
      "parameters": { "amount": 2, "unit": "seconds" }
    },
    {
      "id": "aggregate-items",
      "name": "Aggregate All Items",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [2100, 100],
      "parameters": { "aggregate": "aggregateAllItemData", "options": {} }
    },
    {
      "id": "build-anki-deck",
      "name": "Build APKG Deck",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2300, 100],
      "parameters": {
        "jsCode": "// Build APKG deck using Python genanki script\n// The generate-apkg script is in n8n's PATH via NixOS configuration\nconst { execSync } = require('child_process');\n\ntry {\n  const items = ($input.first().json.data || []);\n  const valid = items.filter(i => i.imageBase64 && i.imageHash);\n  const errors = items.filter(i => i.error);\n\n  if (valid.length === 0) {\n    return [{ json: { success: false, error: 'No valid items to create deck' } }];\n  }\n\n  // Prepare input for Python script\n  const inputData = {\n    deckName: 'Vocabulary',\n    cards: valid.map(item => ({\n      word: item.word,\n      imageBase64: item.imageBase64,\n      mimeType: item.mimeType || 'image/jpeg'\n    }))\n  };\n\n  // Call generate-apkg script via stdin\n  // Script reads JSON from stdin and outputs JSON with apkgBase64\n  const result = execSync('generate-apkg', {\n    input: JSON.stringify(inputData),\n    encoding: 'utf-8',\n    maxBuffer: 100 * 1024 * 1024, // 100MB buffer for large decks\n    timeout: 60000 // 60 second timeout\n  });\n\n  const output = JSON.parse(result);\n\n  if (!output.success) {\n    return [{ json: { success: false, error: output.error || 'APKG generation failed' } }];\n  }\n\n  // Return result with APKG data (renamed from zipBase64 to apkgBase64 for clarity)\n  return [{ json: {\n    success: true,\n    cardCount: output.cardCount,\n    words: output.words,\n    apkgBase64: output.apkgBase64,\n    apkgSizeBytes: output.apkgSizeBytes,\n    failedCount: errors.length + (output.failedCount || 0)\n  }}];\n} catch (e) {\n  // Handle execution errors\n  const errorMsg = e.stderr ? e.stderr.toString() : e.message;\n  return [{ json: { success: false, error: 'APKG generation error: ' + errorMsg } }];\n}\n"
      }
    },
    {
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2500, 100],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": { "responseCode": 200 }
      }
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{ "node": "Normalize Input", "type": "main", "index": 0 }]]
    },
    "Normalize Input": {
      "main": [[{ "node": "Check Valid", "type": "main", "index": 0 }]]
    },
    "Check Valid": {
      "main": [
        [{ "node": "Extract Vocabulary (Vision)", "type": "main", "index": 0 }],
        [{ "node": "Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Extract Vocabulary (Vision)": {
      "main": [
        [{ "node": "Parse Vocabulary JSON", "type": "main", "index": 0 }],
        [{ "node": "Vision Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Parse Vocabulary JSON": {
      "main": [[{ "node": "Check Parse Error", "type": "main", "index": 0 }]]
    },
    "Check Parse Error": {
      "main": [
        [{ "node": "Loop Over Items", "type": "main", "index": 0 }],
        [{ "node": "Parse Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Loop Over Items": {
      "main": [
        [{ "node": "Aggregate All Items", "type": "main", "index": 0 }],
        [{ "node": "Generate Image", "type": "main", "index": 0 }]
      ]
    },
    "Generate Image": {
      "main": [
        [{ "node": "Extract Image Data", "type": "main", "index": 0 }],
        [{ "node": "Handle Image Error", "type": "main", "index": 0 }]
      ]
    },
    "Handle Image Error": {
      "main": [[{ "node": "Wait (Rate Limit)", "type": "main", "index": 0 }]]
    },
    "Extract Image Data": {
      "main": [[{ "node": "Wait (Rate Limit)", "type": "main", "index": 0 }]]
    },
    "Wait (Rate Limit)": {
      "main": [[{ "node": "Loop Over Items", "type": "main", "index": 0 }]]
    },
    "Aggregate All Items": {
      "main": [[{ "node": "Build AnkiApp Deck", "type": "main", "index": 0 }]]
    },
    "Build AnkiApp Deck": {
      "main": [[{ "node": "Success Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "active": true
}
