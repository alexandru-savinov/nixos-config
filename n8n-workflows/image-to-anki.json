{
  "id": "image-to-anki",
  "name": "Image to AnkiApp Deck",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        100,
        300
      ],
      "webhookId": "image-to-anki",
      "parameters": {
        "path": "image-to-anki",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        300,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-image-url",
              "leftValue": "={{ $json.body.imageUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        500,
        500
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: \"Missing imageUrl in request body. Send POST with {\\\"imageUrl\\\": \\\"https://...\\\"}\" }) }}",
        "options": {
          "responseCode": 400
        }
      }
    },
    {
      "id": "vision-extract",
      "name": "Extract Vocabulary (Vision)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        500,
        300
      ],
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.OPENROUTER_API_KEY }}"
            },
            {
              "name": "HTTP-Referer",
              "value": "https://rpi5.tail4249a9.ts.net"
            },
            {
              "name": "X-Title",
              "value": "Image-to-Anki"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'anthropic/claude-sonnet-4', messages: [{ role: 'user', content: [{ type: 'text', text: 'Extract all vocabulary items from this educational image. Return ONLY a valid JSON array of objects with \"word\" (the English vocabulary word) and \"description\" (a brief 3-5 word description suitable for generating a simple illustration). Example: [{\"word\": \"bed\", \"description\": \"furniture for sleeping\"}]. Return ONLY the JSON array, no markdown, no code blocks, no other text.' }, { type: 'image_url', image_url: { url: $json.body.imageUrl } }] }] }) }}",
        "options": {
          "timeout": 120000
        }
      }
    },
    {
      "id": "parse-vocabulary",
      "name": "Parse Vocabulary JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        300
      ],
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst originalImageUrl = $('Webhook Trigger').first().json.body.imageUrl;\n\ntry {\n  const content = response.choices?.[0]?.message?.content || '';\n  let jsonStr = content.trim();\n\n  // Remove markdown code blocks if present\n  const jsonStart = jsonStr.indexOf('```json');\n  const codeStart = jsonStr.indexOf('```');\n  const codeEnd = jsonStr.lastIndexOf('```');\n\n  if (jsonStart !== -1 && codeEnd > jsonStart + 7) {\n    jsonStr = jsonStr.substring(jsonStart + 7, codeEnd).trim();\n  } else if (codeStart !== -1 && codeEnd > codeStart + 3) {\n    jsonStr = jsonStr.substring(codeStart + 3, codeEnd).trim();\n  }\n\n  // Skip any leading newlines or whitespace\n  jsonStr = jsonStr.trim();\n\n  // If it starts with [ it's already JSON\n  if (!jsonStr.startsWith('[')) {\n    throw new Error('Expected JSON array, got: ' + jsonStr.substring(0, 50));\n  }\n\n  const vocabulary = JSON.parse(jsonStr);\n  if (!Array.isArray(vocabulary)) throw new Error('Response is not an array');\n  if (vocabulary.length === 0) throw new Error('No vocabulary items found');\n\n  return vocabulary.map((item, index) => ({\n    json: { index, word: item.word, description: item.description, originalImageUrl, totalItems: vocabulary.length }\n  }));\n} catch (error) {\n  return [{ json: { error: 'Parse failed: ' + error.message, rawContent: response.choices?.[0]?.message?.content?.substring(0, 500) || 'No content', originalImageUrl } }];\n}\n"
      }
    },
    {
      "id": "check-parse-error",
      "name": "Check Parse Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        900,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notExists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "parse-error-response",
      "name": "Parse Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1100,
        500
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.error, rawContent: $json.rawContent }) }}",
        "options": {
          "responseCode": 500
        }
      }
    },
    {
      "id": "loop-items",
      "name": "Loop Over Items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1100,
        300
      ],
      "parameters": {
        "batchSize": 1,
        "options": {}
      }
    },
    {
      "id": "generate-image",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1300,
        300
      ],
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.OPENROUTER_API_KEY }}"
            },
            {
              "name": "HTTP-Referer",
              "value": "https://rpi5.tail4249a9.ts.net"
            },
            {
              "name": "X-Title",
              "value": "Image-to-Anki"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'google/gemini-2.5-flash-image', messages: [{ role: 'user', content: 'Generate a simple, clean illustration for a vocabulary flashcard. Subject: ' + $json.word + ' (' + $json.description + '). Style: flat design, minimal, centered, white background, suitable for educational flashcard. Do not include any text in the image.' }] }) }}",
        "options": {
          "timeout": 120000
        }
      }
    },
    {
      "id": "extract-image-data",
      "name": "Extract Image Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1500,
        300
      ],
      "parameters": {
        "jsCode": "// Extract base64 image from OpenRouter response and calculate SHA256\n// Pure JavaScript implementation for n8n Code node\nconst response = $input.first().json;\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\n\n// Pure JavaScript base64 decoder\nfunction base64Decode(base64) {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  let output = [];\n\n  // Remove padding and whitespace\n  base64 = base64.replace(/[\\s=]/g, '');\n\n  for (let i = 0; i < base64.length; i += 4) {\n    const idx0 = chars.indexOf(base64[i]);\n    const idx1 = chars.indexOf(base64[i + 1]);\n    const idx2 = i + 2 < base64.length ? chars.indexOf(base64[i + 2]) : 64;\n    const idx3 = i + 3 < base64.length ? chars.indexOf(base64[i + 3]) : 64;\n\n    const triplet = (idx0 << 18) | (idx1 << 12) | (idx2 << 6) | idx3;\n\n    output.push((triplet >> 16) & 255);\n    if (idx2 !== 64) output.push((triplet >> 8) & 255);\n    if (idx3 !== 64) output.push(triplet & 255);\n  }\n\n  return new Uint8Array(output);\n}\n\n// SHA256 implementation (pure JavaScript)\nfunction sha256(data) {\n  function rightRotate(value, amount) {\n    return (value >>> amount) | (value << (32 - amount));\n  }\n\n  const mathPow = Math.pow;\n  const maxWord = mathPow(2, 32);\n  let result = '';\n\n  const words = [];\n  const asciiBitLength = data.length * 8;\n\n  let hash = [];\n  const k = [];\n  let primeCounter = 0;\n\n  function isNotPrime(n) {\n    for (let factor = 2; factor * factor <= n; factor++) {\n      if (n % factor === 0) return true;\n    }\n    return false;\n  }\n\n  for (let i = 0; i < 64; primeCounter++) {\n    if (!isNotPrime(primeCounter)) {\n      if (i < 8) {\n        hash[i] = (mathPow(primeCounter, 0.5) * maxWord) | 0;\n      }\n      k[i] = (mathPow(primeCounter, 1 / 3) * maxWord) | 0;\n      i++;\n    }\n  }\n\n  data += '\\x80';\n  while (data.length % 64 - 56) data += '\\x00';\n  for (let i = 0; i < data.length; i++) {\n    const j = data.charCodeAt(i);\n    if (j >> 8) return;\n    words[i >> 2] |= j << ((3 - i) % 4) * 8;\n  }\n  words[words.length] = (asciiBitLength / maxWord) | 0;\n  words[words.length] = asciiBitLength;\n\n  for (let j = 0; j < words.length; ) {\n    const w = words.slice(j, j += 16);\n    const oldHash = hash.slice(0);\n\n    for (let i = 0; i < 64; i++) {\n      const w15 = w[i - 15], w2 = w[i - 2];\n\n      const a = hash[0], e = hash[4];\n      const temp1 = hash[7]\n        + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25))\n        + ((e & hash[5]) ^ (~e & hash[6]))\n        + k[i]\n        + (w[i] = (i < 16) ? w[i] : (\n            w[i - 16]\n            + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3))\n            + w[i - 7]\n            + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))\n          ) | 0\n        );\n\n      const temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22))\n        + ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));\n\n      hash = [(temp1 + temp2) | 0].concat(hash);\n      hash[4] = (hash[4] + temp1) | 0;\n    }\n\n    for (let i = 0; i < 8; i++) {\n      hash[i] = (hash[i] + oldHash[i]) | 0;\n    }\n  }\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 3; j + 1; j--) {\n      const b = (hash[i] >> (j * 8)) & 255;\n      result += ((b < 16) ? '0' : '') + b.toString(16);\n    }\n  }\n  return result;\n}\n\n// SHA256 for binary data (from Uint8Array)\nfunction sha256Binary(uint8Array) {\n  let str = '';\n  for (let i = 0; i < uint8Array.length; i++) {\n    str += String.fromCharCode(uint8Array[i]);\n  }\n  return sha256(str);\n}\n\ntry {\n  const message = response.choices?.[0]?.message;\n  const images = message?.images;\n  let base64Data = null;\n  let mimeType = 'image/png';\n\n  if (images && images.length > 0) {\n    const imageUrl = images[0].image_url?.url || images[0].url || images[0];\n    if (typeof imageUrl === 'string' && imageUrl.includes('base64,')) {\n      base64Data = imageUrl.split('base64,')[1];\n      if (imageUrl.includes('image/jpeg')) mimeType = 'image/jpeg';\n    }\n  }\n\n  if (!base64Data && message?.content) {\n    const match = message.content.match(/data:image\\/([^;]+);base64,([A-Za-z0-9+/=]+)/);\n    if (match) {\n      mimeType = 'image/' + match[1];\n      base64Data = match[2];\n    }\n  }\n\n  if (!base64Data) throw new Error('No image in response: ' + (message?.content?.substring(0, 200) || 'empty'));\n\n  // Decode base64 to binary using pure JS\n  const bytes = base64Decode(base64Data);\n  const hash = sha256Binary(bytes);\n\n  return [{ json: { index, word, description, imageBase64: base64Data, imageHash: hash, mimeType, imageSizeBytes: bytes.length } }];\n} catch (error) {\n  return [{ json: { index, word, description, error: 'Image gen failed: ' + error.message, imageBase64: null, imageHash: null, mimeType: null } }];\n}\n"
      }
    },
    {
      "id": "wait-rate-limit",
      "name": "Wait (Rate Limit)",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1700,
        300
      ],
      "parameters": {
        "amount": 2,
        "unit": "seconds"
      }
    },
    {
      "id": "aggregate-items",
      "name": "Aggregate All Items",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        100
      ],
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      }
    },
    {
      "id": "build-anki-deck",
      "name": "Build AnkiApp Deck",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2100,
        100
      ],
      "parameters": {
        "jsCode": "// Build AnkiApp XML and ZIP\n// Pure JavaScript implementation for n8n Code node (no Buffer, atob, btoa)\nconst allData = $input.first().json;\nconst items = allData.data || [];\n\nconst validItems = items.filter(item => item.imageBase64 && item.imageHash);\nconst errorItems = items.filter(item => item.error);\n\nif (validItems.length === 0) {\n  return [{ json: { success: false, error: 'No valid items', failedItems: errorItems.map(i => ({ word: i.word, error: i.error })) } }];\n}\n\nfunction escapeXml(str) {\n  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n}\n\nlet xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<deck name=\"Vocabulary Deck\" tags=\"vocabulary,ai-generated\">\\n  <fields>\\n    <img name=\"Image\" sides=\"10\"/>\\n    <text lang=\"en-US\" name=\"Word\" sides=\"01\"/>\\n  </fields>\\n  <cards>\\n';\nfor (const item of validItems) {\n  xml += '    <card>\\n      <img name=\"Image\" id=\"' + item.imageHash + '\"/>\\n      <text name=\"Word\">' + escapeXml(item.word) + '</text>\\n    </card>\\n';\n}\nxml += '  </cards>\\n</deck>\\n';\n\n// Pure JavaScript base64 functions\nconst base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction base64Decode(base64) {\n  let output = [];\n  base64 = base64.replace(/[\\s=]/g, '');\n  for (let i = 0; i < base64.length; i += 4) {\n    const idx0 = base64Chars.indexOf(base64[i]);\n    const idx1 = base64Chars.indexOf(base64[i + 1]);\n    const idx2 = i + 2 < base64.length ? base64Chars.indexOf(base64[i + 2]) : 64;\n    const idx3 = i + 3 < base64.length ? base64Chars.indexOf(base64[i + 3]) : 64;\n    const triplet = (idx0 << 18) | (idx1 << 12) | (idx2 << 6) | idx3;\n    output.push((triplet >> 16) & 255);\n    if (idx2 !== 64) output.push((triplet >> 8) & 255);\n    if (idx3 !== 64) output.push(triplet & 255);\n  }\n  return new Uint8Array(output);\n}\n\nfunction base64Encode(uint8Array) {\n  let result = '';\n  for (let i = 0; i < uint8Array.length; i += 3) {\n    const b0 = uint8Array[i];\n    const b1 = i + 1 < uint8Array.length ? uint8Array[i + 1] : 0;\n    const b2 = i + 2 < uint8Array.length ? uint8Array[i + 2] : 0;\n    result += base64Chars[(b0 >> 2) & 63];\n    result += base64Chars[((b0 << 4) | (b1 >> 4)) & 63];\n    result += i + 1 < uint8Array.length ? base64Chars[((b1 << 2) | (b2 >> 6)) & 63] : '=';\n    result += i + 2 < uint8Array.length ? base64Chars[b2 & 63] : '=';\n  }\n  return result;\n}\n\nfunction crc32(uint8Array) {\n  let crc = 0xFFFFFFFF;\n  const table = new Uint32Array(256);\n  for (let i = 0; i < 256; i++) {\n    let c = i;\n    for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);\n    table[i] = c;\n  }\n  for (let i = 0; i < uint8Array.length; i++) crc = table[(crc ^ uint8Array[i]) & 0xFF] ^ (crc >>> 8);\n  return (crc ^ 0xFFFFFFFF) >>> 0;\n}\n\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i) & 0xFF;\n  }\n  return arr;\n}\n\nfunction concatUint8Arrays(...arrays) {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nfunction writeUint16LE(value) {\n  return new Uint8Array([value & 0xFF, (value >> 8) & 0xFF]);\n}\n\nfunction writeUint32LE(value) {\n  return new Uint8Array([value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF, (value >> 24) & 0xFF]);\n}\n\nfunction createZip(files) {\n  const localHeaders = [];\n  const centralHeaders = [];\n  let offset = 0;\n\n  for (const file of files) {\n    const nameBytes = stringToUint8Array(file.name);\n    const dataBytes = file.data;\n    const crc = crc32(dataBytes);\n\n    const localHeader = concatUint8Arrays(\n      writeUint32LE(0x04034b50), writeUint16LE(20), writeUint16LE(0), writeUint16LE(0),\n      writeUint16LE(0), writeUint16LE(0), writeUint32LE(crc),\n      writeUint32LE(dataBytes.length), writeUint32LE(dataBytes.length),\n      writeUint16LE(nameBytes.length), writeUint16LE(0)\n    );\n    localHeaders.push(concatUint8Arrays(localHeader, nameBytes, dataBytes));\n\n    const centralHeader = concatUint8Arrays(\n      writeUint32LE(0x02014b50), writeUint16LE(20), writeUint16LE(20), writeUint16LE(0),\n      writeUint16LE(0), writeUint16LE(0), writeUint16LE(0), writeUint32LE(crc),\n      writeUint32LE(dataBytes.length), writeUint32LE(dataBytes.length),\n      writeUint16LE(nameBytes.length), writeUint16LE(0), writeUint16LE(0),\n      writeUint16LE(0), writeUint16LE(0), writeUint32LE(0), writeUint32LE(offset)\n    );\n    centralHeaders.push(concatUint8Arrays(centralHeader, nameBytes));\n    offset += localHeader.length + nameBytes.length + dataBytes.length;\n  }\n\n  const localData = concatUint8Arrays(...localHeaders);\n  const centralData = concatUint8Arrays(...centralHeaders);\n\n  const endRecord = concatUint8Arrays(\n    writeUint32LE(0x06054b50), writeUint16LE(0), writeUint16LE(0),\n    writeUint16LE(files.length), writeUint16LE(files.length),\n    writeUint32LE(centralData.length), writeUint32LE(localData.length), writeUint16LE(0)\n  );\n\n  return concatUint8Arrays(localData, centralData, endRecord);\n}\n\nconst files = [{ name: 'deck.xml', data: stringToUint8Array(xml) }];\nfor (const item of validItems) {\n  const ext = item.mimeType === 'image/jpeg' ? 'jpg' : 'png';\n  files.push({ name: 'blobs/' + item.imageHash + '.' + ext, data: base64Decode(item.imageBase64) });\n}\n\nconst zipData = createZip(files);\nconst zipBase64 = base64Encode(zipData);\n\nreturn [{ json: { success: true, cardCount: validItems.length, words: validItems.map(i => i.word), zipBase64, zipSizeBytes: zipData.length } }];\n"
      }
    },
    {
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2300,
        100
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200
        }
      }
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Extract Vocabulary (Vision)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Vocabulary (Vision)": {
      "main": [
        [
          {
            "node": "Parse Vocabulary JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Vocabulary JSON": {
      "main": [
        [
          {
            "node": "Check Parse Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Parse Error": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Aggregate All Items",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image": {
      "main": [
        [
          {
            "node": "Extract Image Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Image Data": {
      "main": [
        [
          {
            "node": "Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate All Items": {
      "main": [
        [
          {
            "node": "Build AnkiApp Deck",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AnkiApp Deck": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "active": true
}