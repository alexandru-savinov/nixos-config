{
  "id": "image-to-anki",
  "name": "Image to AnkiApp Deck",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        100,
        300
      ],
      "webhookId": "image-to-anki",
      "parameters": {
        "path": "image-to-anki",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        300,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-image-url",
              "leftValue": "={{ $json.body.imageUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        500,
        500
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: \"Missing imageUrl in request body. Send POST with {\\\"imageUrl\\\": \\\"https://...\\\"}\" }) }}",
        "options": {
          "responseCode": 400
        }
      }
    },
    {
      "id": "vision-extract",
      "name": "Extract Vocabulary (Vision)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        500,
        300
      ],
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}"
            },
            {
              "name": "HTTP-Referer",
              "value": "https://rpi5.tail4249a9.ts.net"
            },
            {
              "name": "X-Title",
              "value": "Image-to-Anki"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'anthropic/claude-sonnet-4', messages: [{ role: 'user', content: [{ type: 'text', text: 'Extract all vocabulary items from this educational image. Return ONLY a valid JSON array of objects with \"word\" (the English vocabulary word) and \"description\" (a brief 3-5 word description suitable for generating a simple illustration). Example: [{\"word\": \"bed\", \"description\": \"furniture for sleeping\"}]. Return ONLY the JSON array, no markdown, no code blocks, no other text.' }, { type: 'image_url', image_url: { url: $json.body.imageUrl } }] }] }) }}",
        "options": {
          "timeout": 120000
        }
      }
    },
    {
      "id": "parse-vocabulary",
      "name": "Parse Vocabulary JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        300
      ],
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst originalImageUrl = $('Webhook Trigger').first().json.body.imageUrl;\n\ntry {\n  const content = response.choices?.[0]?.message?.content || '';\n  let jsonStr = content.trim();\n\n  // Remove markdown code blocks if present\n  const jsonStart = jsonStr.indexOf('```json');\n  const codeStart = jsonStr.indexOf('```');\n  const codeEnd = jsonStr.lastIndexOf('```');\n\n  if (jsonStart !== -1 && codeEnd > jsonStart + 7) {\n    jsonStr = jsonStr.substring(jsonStart + 7, codeEnd).trim();\n  } else if (codeStart !== -1 && codeEnd > codeStart + 3) {\n    jsonStr = jsonStr.substring(codeStart + 3, codeEnd).trim();\n  }\n\n  // Skip any leading newlines or whitespace\n  jsonStr = jsonStr.trim();\n\n  // If it starts with [ it's already JSON\n  if (!jsonStr.startsWith('[')) {\n    throw new Error('Expected JSON array, got: ' + jsonStr.substring(0, 50));\n  }\n\n  const vocabulary = JSON.parse(jsonStr);\n  if (!Array.isArray(vocabulary)) throw new Error('Response is not an array');\n  if (vocabulary.length === 0) throw new Error('No vocabulary items found');\n\n  return vocabulary.map((item, index) => ({\n    json: { index, word: item.word, description: item.description, originalImageUrl, totalItems: vocabulary.length }\n  }));\n} catch (error) {\n  return [{ json: { error: 'Parse failed: ' + error.message, rawContent: response.choices?.[0]?.message?.content?.substring(0, 500) || 'No content', originalImageUrl } }];\n}\n"
      }
    },
    {
      "id": "check-parse-error",
      "name": "Check Parse Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        900,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notExists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "parse-error-response",
      "name": "Parse Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1100,
        500
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.error, rawContent: $json.rawContent }) }}",
        "options": {
          "responseCode": 500
        }
      }
    },
    {
      "id": "loop-items",
      "name": "Loop Over Items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1100,
        300
      ],
      "parameters": {
        "batchSize": 5,
        "options": {}
      }
    },
    {
      "id": "generate-image",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1300,
        300
      ],
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}"
            },
            {
              "name": "HTTP-Referer",
              "value": "https://rpi5.tail4249a9.ts.net"
            },
            {
              "name": "X-Title",
              "value": "Image-to-Anki"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'google/gemini-2.5-flash-image', messages: [{ role: 'user', content: 'Generate a simple, clean illustration for a vocabulary flashcard. Subject: ' + $json.word + ' (' + $json.description + '). Style: flat design, minimal, centered, white background, suitable for educational flashcard. Do not include any text in the image.' }] }) }}",
        "options": {
          "timeout": 120000
        }
      }
    },
    {
      "id": "extract-image-data",
      "name": "Extract Image Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1500,
        300
      ],
      "parameters": {
        "jsCode": "// Extract base64 image from OpenRouter response and calculate SHA256\n// Optimized: Uses Node.js crypto (requires NODE_FUNCTION_ALLOW_BUILTIN=crypto)\nconst crypto = require('crypto');\n\nconst response = $input.first().json;\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\n\ntry {\n  const message = response.choices?.[0]?.message;\n  const images = message?.images;\n  let base64Data = null;\n  let mimeType = 'image/png';\n\n  if (images && images.length > 0) {\n    const imageUrl = images[0].image_url?.url || images[0].url || images[0];\n    if (typeof imageUrl === 'string' && imageUrl.includes('base64,')) {\n      base64Data = imageUrl.split('base64,')[1];\n      if (imageUrl.includes('image/jpeg')) mimeType = 'image/jpeg';\n    }\n  }\n\n  if (!base64Data && message?.content) {\n    const match = message.content.match(/data:image\\/([^;]+);base64,([A-Za-z0-9+/=]+)/);\n    if (match) {\n      mimeType = 'image/' + match[1];\n      base64Data = match[2];\n    }\n  }\n\n  if (!base64Data) throw new Error('No image in response: ' + (message?.content?.substring(0, 200) || 'empty'));\n\n  // Use Node.js Buffer for base64 decoding (fast native implementation)\n  const bytes = Buffer.from(base64Data, 'base64');\n\n  // Use Node.js crypto for SHA256 (fast native implementation)\n  const hash = crypto.createHash('sha256').update(bytes).digest('hex');\n\n  return [{ json: { index, word, description, imageBase64: base64Data, imageHash: hash, mimeType, imageSizeBytes: bytes.length } }];\n} catch (error) {\n  return [{ json: { index, word, description, error: 'Image gen failed: ' + error.message, imageBase64: null, imageHash: null, mimeType: null } }];\n}\n"
      }
    },
    {
      "id": "wait-rate-limit",
      "name": "Wait (Rate Limit)",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1700,
        300
      ],
      "parameters": {
        "amount": 2,
        "unit": "seconds"
      }
    },
    {
      "id": "aggregate-items",
      "name": "Aggregate All Items",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        100
      ],
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      }
    },
    {
      "id": "build-anki-deck",
      "name": "Build AnkiApp Deck",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2100,
        100
      ],
      "parameters": {
        "jsCode": "// Build AnkiApp XML and ZIP - Optimized with Node.js Buffer\nconst allData = $input.first().json;\nconst items = allData.data || [];\n\nconst validItems = items.filter(item => item.imageBase64 && item.imageHash);\nconst errorItems = items.filter(item => item.error);\n\nif (validItems.length === 0) {\n  return [{ json: { success: false, error: 'No valid items', failedItems: errorItems.map(i => ({ word: i.word, error: i.error })) } }];\n}\n\nfunction escapeXml(str) {\n  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n}\n\nlet xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<deck name=\"Vocabulary Deck\" tags=\"vocabulary,ai-generated\">\\n  <fields>\\n    <img name=\"Image\" sides=\"10\"/>\\n    <text lang=\"en-US\" name=\"Word\" sides=\"01\"/>\\n  </fields>\\n  <cards>\\n';\nfor (const item of validItems) {\n  xml += '    <card>\\n      <img name=\"Image\" id=\"' + item.imageHash + '\"/>\\n      <text name=\"Word\">' + escapeXml(item.word) + '</text>\\n    </card>\\n';\n}\nxml += '  </cards>\\n</deck>\\n';\n\n// CRC32 with lookup table (faster)\nconst crc32Table = new Uint32Array(256);\nfor (let i = 0; i < 256; i++) {\n  let c = i;\n  for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);\n  crc32Table[i] = c;\n}\n\nfunction crc32(data) {\n  let crc = 0xFFFFFFFF;\n  for (let i = 0; i < data.length; i++) {\n    crc = crc32Table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);\n  }\n  return (crc ^ 0xFFFFFFFF) >>> 0;\n}\n\nfunction createZip(files) {\n  const parts = [];\n  const centralHeaders = [];\n  let offset = 0;\n\n  for (const file of files) {\n    const nameBytes = Buffer.from(file.name, 'utf8');\n    const dataBytes = file.data;\n    const crc = crc32(dataBytes);\n\n    // Local file header\n    const localHeader = Buffer.alloc(30);\n    localHeader.writeUInt32LE(0x04034b50, 0);  // signature\n    localHeader.writeUInt16LE(20, 4);          // version needed\n    localHeader.writeUInt16LE(0, 6);           // flags\n    localHeader.writeUInt16LE(0, 8);           // compression (store)\n    localHeader.writeUInt16LE(0, 10);          // mod time\n    localHeader.writeUInt16LE(0, 12);          // mod date\n    localHeader.writeUInt32LE(crc, 14);        // crc32\n    localHeader.writeUInt32LE(dataBytes.length, 18);  // compressed size\n    localHeader.writeUInt32LE(dataBytes.length, 22);  // uncompressed size\n    localHeader.writeUInt16LE(nameBytes.length, 26);  // name length\n    localHeader.writeUInt16LE(0, 28);          // extra length\n\n    parts.push(localHeader, nameBytes, dataBytes);\n\n    // Central directory header\n    const centralHeader = Buffer.alloc(46);\n    centralHeader.writeUInt32LE(0x02014b50, 0);\n    centralHeader.writeUInt16LE(20, 4);\n    centralHeader.writeUInt16LE(20, 6);\n    centralHeader.writeUInt16LE(0, 8);\n    centralHeader.writeUInt16LE(0, 10);\n    centralHeader.writeUInt16LE(0, 12);\n    centralHeader.writeUInt16LE(0, 14);\n    centralHeader.writeUInt32LE(crc, 16);\n    centralHeader.writeUInt32LE(dataBytes.length, 20);\n    centralHeader.writeUInt32LE(dataBytes.length, 24);\n    centralHeader.writeUInt16LE(nameBytes.length, 28);\n    centralHeader.writeUInt16LE(0, 30);\n    centralHeader.writeUInt16LE(0, 32);\n    centralHeader.writeUInt16LE(0, 34);\n    centralHeader.writeUInt16LE(0, 36);\n    centralHeader.writeUInt32LE(0, 38);\n    centralHeader.writeUInt32LE(offset, 42);\n\n    centralHeaders.push(centralHeader, nameBytes);\n    offset += 30 + nameBytes.length + dataBytes.length;\n  }\n\n  const centralDir = Buffer.concat(centralHeaders);\n  const endRecord = Buffer.alloc(22);\n  endRecord.writeUInt32LE(0x06054b50, 0);\n  endRecord.writeUInt16LE(0, 4);\n  endRecord.writeUInt16LE(0, 6);\n  endRecord.writeUInt16LE(files.length, 8);\n  endRecord.writeUInt16LE(files.length, 10);\n  endRecord.writeUInt32LE(centralDir.length, 12);\n  endRecord.writeUInt32LE(offset, 16);\n  endRecord.writeUInt16LE(0, 20);\n\n  return Buffer.concat([...parts, centralDir, endRecord]);\n}\n\nconst files = [{ name: 'deck.xml', data: Buffer.from(xml, 'utf8') }];\nfor (const item of validItems) {\n  const ext = item.mimeType === 'image/jpeg' ? 'jpg' : 'png';\n  files.push({ name: 'blobs/' + item.imageHash + '.' + ext, data: Buffer.from(item.imageBase64, 'base64') });\n}\n\nconst zipData = createZip(files);\nconst zipBase64 = zipData.toString('base64');\n\nreturn [{ json: { success: true, cardCount: validItems.length, words: validItems.map(i => i.word), zipBase64, zipSizeBytes: zipData.length } }];\n"
      }
    },
    {
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2300,
        100
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200
        }
      }
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Extract Vocabulary (Vision)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Vocabulary (Vision)": {
      "main": [
        [
          {
            "node": "Parse Vocabulary JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Vocabulary JSON": {
      "main": [
        [
          {
            "node": "Check Parse Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Parse Error": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Aggregate All Items",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image": {
      "main": [
        [
          {
            "node": "Extract Image Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Image Data": {
      "main": [
        [
          {
            "node": "Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate All Items": {
      "main": [
        [
          {
            "node": "Build AnkiApp Deck",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AnkiApp Deck": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "active": true
}