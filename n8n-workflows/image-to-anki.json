{
  "id": "image-to-anki",
  "name": "Image to AnkiApp Deck",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 300],
      "webhookId": "image-to-anki",
      "parameters": {
        "path": "image-to-anki",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "normalize-input",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 300],
      "parameters": {
        "jsCode": "// Normalize and validate input - returns error JSON if invalid\nconst body = $input.first().json.body || {};\n\nif (body.imageUrl && typeof body.imageUrl === 'string' && body.imageUrl.length > 0) {\n  return [{ json: { ...($input.first().json), imageSource: body.imageUrl, inputType: 'url', isValid: true } }];\n}\n\nif (body.imageData && typeof body.imageData === 'string' && body.imageData.length > 0) {\n  let data = body.imageData;\n  if (!data.startsWith('data:')) {\n    data = 'data:image/png;base64,' + data;\n  }\n  return [{ json: { ...($input.first().json), imageSource: data, inputType: 'base64', isValid: true } }];\n}\n\n// Invalid - return error marker\nreturn [{ json: { isValid: false, error: 'Missing image. Send POST with {\"imageUrl\": \"...\"} or {\"imageData\": \"...\"}' } }];\n"
      }
    },
    {
      "id": "check-valid",
      "name": "Check Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [500, 300],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose" },
          "conditions": [
            {
              "id": "is-valid",
              "leftValue": "={{ $json.isValid }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [700, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.error }) }}",
        "options": { "responseCode": 400 }
      }
    },
    {
      "id": "vision-extract",
      "name": "Extract Vocabulary (Vision)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [700, 300],
      "onError": "continueErrorOutput",
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}" },
            { "name": "HTTP-Referer", "value": "https://rpi5.tail4249a9.ts.net" },
            { "name": "X-Title", "value": "Image-to-Anki" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'google/gemini-2.5-flash', max_tokens: 4096, zdr: true, messages: [{ role: 'user', content: [{ type: 'text', text: 'TASK: Extract EVERY vocabulary item from this educational infographic. Be EXHAUSTIVE - these images often contain 10-30+ items.\\n\\nINSTRUCTIONS:\\n1. Scan the ENTIRE image systematically\\n2. Include EVERY labeled word/item\\n3. Count and verify you captured everything\\n\\nOUTPUT: Return ONLY a JSON array: [{\"word\": \"...\", \"description\": \"3-5 words for illustration\"}]\\n\\nNo markdown, no code blocks.' }, { type: 'image_url', image_url: { url: $json.imageSource } }] }] }) }}",
        "options": { "timeout": 120000 }
      }
    },
    {
      "id": "vision-error-response",
      "name": "Vision Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'Vision API failed: ' + ($json.error?.message || $json.message || 'Unknown error'), details: $json.error?.description || $json.statusCode || null }) }}",
        "options": { "responseCode": 502 }
      }
    },
    {
      "id": "parse-vocabulary",
      "name": "Parse Vocabulary JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300],
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst imageSource = $('Normalize Input').first().json.imageSource;\nconst inputType = $('Normalize Input').first().json.inputType;\n\nconst content = response.choices?.[0]?.message?.content || '';\nif (!content) {\n  return [{ json: { parseError: 'No content in LLM response' } }];\n}\n\nlet jsonStr = content.trim();\nif (jsonStr.includes('```')) {\n  const start = jsonStr.indexOf('[');\n  const end = jsonStr.lastIndexOf(']') + 1;\n  if (start >= 0 && end > start) jsonStr = jsonStr.substring(start, end);\n}\n\nlet vocabulary;\ntry {\n  vocabulary = JSON.parse(jsonStr);\n} catch (e) {\n  return [{ json: { parseError: 'Invalid JSON: ' + e.message, rawContent: jsonStr.substring(0, 200) } }];\n}\n\nif (!Array.isArray(vocabulary) || vocabulary.length === 0) {\n  return [{ json: { parseError: 'No vocabulary found', rawContent: jsonStr.substring(0, 200) } }];\n}\n\nreturn vocabulary.map((item, index) => ({\n  json: { index, word: item.word, description: item.description, imageSource, inputType, totalItems: vocabulary.length }\n}));\n"
      }
    },
    {
      "id": "check-parse-error",
      "name": "Check Parse Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1100, 300],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose" },
          "conditions": [
            {
              "id": "no-error",
              "leftValue": "={{ $json.parseError }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notExists", "singleValue": true }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "parse-error-response",
      "name": "Parse Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1300, 500],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.parseError, rawContent: $json.rawContent }) }}",
        "options": { "responseCode": 500 }
      }
    },
    {
      "id": "loop-items",
      "name": "Loop Over Items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1300, 300],
      "parameters": { "batchSize": 5, "options": {} }
    },
    {
      "id": "generate-image",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 300],
      "onError": "continueErrorOutput",
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "=Bearer {{ $env.OPENROUTER_API_KEY }}" },
            { "name": "HTTP-Referer", "value": "https://rpi5.tail4249a9.ts.net" },
            { "name": "X-Title", "value": "Image-to-Anki" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'bytedance-seed/seedream-4.5', modalities: ['text', 'image'], zdr: false, messages: [{ role: 'user', content: 'Generate a simple illustration for flashcard: ' + $json.word + ' (' + $json.description + '). Style: flat, minimal, white background, no text.' }] }) }}",
        "options": { "timeout": 120000 }
      }
    },
    {
      "id": "handle-image-error",
      "name": "Handle Image Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 500],
      "parameters": {
        "jsCode": "// Handle HTTP errors from image generation gracefully\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\nconst errorInfo = $input.first().json;\nconst errorMsg = errorInfo.error?.message || errorInfo.message || 'Image generation failed';\nreturn [{ json: { index, word, description, error: errorMsg, imageBase64: null, imageHash: null } }];\n"
      }
    },
    {
      "id": "extract-image-data",
      "name": "Extract Image Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 300],
      "parameters": {
        "jsCode": "const crypto = require('crypto');\nconst response = $input.first().json;\nconst prevData = $('Loop Over Items').first().json;\nconst { word, description, index } = prevData;\n\ntry {\n  const message = response.choices?.[0]?.message;\n  let base64Data = null, mimeType = 'image/png';\n\n  if (message?.images?.[0]) {\n    const img = message.images[0];\n    const url = img.image_url?.url || img.url || img;\n    if (typeof url === 'string' && url.includes('base64,')) {\n      base64Data = url.split('base64,')[1];\n      if (url.includes('jpeg')) mimeType = 'image/jpeg';\n    }\n  }\n\n  if (!base64Data && message?.content) {\n    const m = message.content.match(/data:image\\/([^;]+);base64,([A-Za-z0-9+/=]+)/);\n    if (m) { mimeType = 'image/' + m[1]; base64Data = m[2]; }\n  }\n\n  if (!base64Data) throw new Error('No image');\n\n  const bytes = Buffer.from(base64Data, 'base64');\n  const hash = crypto.createHash('sha256').update(bytes).digest('hex');\n  return [{ json: { index, word, description, imageBase64: base64Data, imageHash: hash, mimeType, imageSizeBytes: bytes.length } }];\n} catch (e) {\n  return [{ json: { index, word, description, error: e.message, imageBase64: null, imageHash: null } }];\n}\n"
      }
    },
    {
      "id": "wait-rate-limit",
      "name": "Wait (Rate Limit)",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1900, 300],
      "parameters": { "amount": 2, "unit": "seconds" }
    },
    {
      "id": "aggregate-items",
      "name": "Aggregate All Items",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [2100, 100],
      "parameters": { "aggregate": "aggregateAllItemData", "options": {} }
    },
    {
      "id": "build-anki-deck",
      "name": "Build AnkiApp Deck",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2300, 100],
      "parameters": {
        "jsCode": "try {\n  const items = ($input.first().json.data || []);\n  const valid = items.filter(i => i.imageBase64 && i.imageHash);\n  const errors = items.filter(i => i.error);\n\n  if (valid.length === 0) return [{ json: { success: false, error: 'No valid items' } }];\n\n  const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;');\n\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<deck name=\"Vocabulary\" tags=\"ai\">\\n<fields><img name=\"Image\" sides=\"10\"/><text lang=\"en-US\" name=\"Word\" sides=\"01\"/></fields>\\n<cards>\\n';\n  for (const i of valid) xml += '<card><img name=\"Image\" id=\"'+i.imageHash+'\"/><text name=\"Word\">'+esc(i.word)+'</text></card>\\n';\n  xml += '</cards></deck>';\n\n  const crc32T = new Uint32Array(256);\n  for(let i=0;i<256;i++){let c=i;for(let j=0;j<8;j++)c=(c&1)?0xEDB88320^(c>>>1):c>>>1;crc32T[i]=c;}\n  const crc32 = d => { let c=0xFFFFFFFF; for(let i=0;i<d.length;i++)c=crc32T[(c^d[i])&0xFF]^(c>>>8); return (c^0xFFFFFFFF)>>>0; };\n\n  const mkZip = files => {\n    const p=[],ch=[];let o=0;\n    for(const f of files){\n      const n=Buffer.from(f.name,'utf8'),d=f.data,cr=crc32(d);\n      const lh=Buffer.alloc(30);lh.writeUInt32LE(0x04034b50,0);lh.writeUInt16LE(20,4);lh.writeUInt32LE(cr,14);lh.writeUInt32LE(d.length,18);lh.writeUInt32LE(d.length,22);lh.writeUInt16LE(n.length,26);\n      p.push(lh,n,d);\n      const cd=Buffer.alloc(46);cd.writeUInt32LE(0x02014b50,0);cd.writeUInt16LE(20,4);cd.writeUInt16LE(20,6);cd.writeUInt32LE(cr,16);cd.writeUInt32LE(d.length,20);cd.writeUInt32LE(d.length,24);cd.writeUInt16LE(n.length,28);cd.writeUInt32LE(o,42);\n      ch.push(cd,n);o+=30+n.length+d.length;\n    }\n    const cd=Buffer.concat(ch),er=Buffer.alloc(22);er.writeUInt32LE(0x06054b50,0);er.writeUInt16LE(files.length,8);er.writeUInt16LE(files.length,10);er.writeUInt32LE(cd.length,12);er.writeUInt32LE(o,16);\n    return Buffer.concat([...p,cd,er]);\n  };\n\n  const files=[{name:'deck.xml',data:Buffer.from(xml)}];\n  for(const i of valid) files.push({name:'blobs/'+i.imageHash+'.'+(i.mimeType==='image/jpeg'?'jpg':'png'),data:Buffer.from(i.imageBase64,'base64')});\n  const zip=mkZip(files);\n  return [{json:{success:true,cardCount:valid.length,words:valid.map(i=>i.word),zipBase64:zip.toString('base64'),zipSizeBytes:zip.length,failedCount:errors.length}}];\n} catch(e) { return [{json:{success:false,error:e.message}}]; }\n"
      }
    },
    {
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2500, 100],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": { "responseCode": 200 }
      }
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{ "node": "Normalize Input", "type": "main", "index": 0 }]]
    },
    "Normalize Input": {
      "main": [[{ "node": "Check Valid", "type": "main", "index": 0 }]]
    },
    "Check Valid": {
      "main": [
        [{ "node": "Extract Vocabulary (Vision)", "type": "main", "index": 0 }],
        [{ "node": "Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Extract Vocabulary (Vision)": {
      "main": [
        [{ "node": "Parse Vocabulary JSON", "type": "main", "index": 0 }],
        [{ "node": "Vision Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Parse Vocabulary JSON": {
      "main": [[{ "node": "Check Parse Error", "type": "main", "index": 0 }]]
    },
    "Check Parse Error": {
      "main": [
        [{ "node": "Loop Over Items", "type": "main", "index": 0 }],
        [{ "node": "Parse Error Response", "type": "main", "index": 0 }]
      ]
    },
    "Loop Over Items": {
      "main": [
        [{ "node": "Aggregate All Items", "type": "main", "index": 0 }],
        [{ "node": "Generate Image", "type": "main", "index": 0 }]
      ]
    },
    "Generate Image": {
      "main": [
        [{ "node": "Extract Image Data", "type": "main", "index": 0 }],
        [{ "node": "Handle Image Error", "type": "main", "index": 0 }]
      ]
    },
    "Handle Image Error": {
      "main": [[{ "node": "Wait (Rate Limit)", "type": "main", "index": 0 }]]
    },
    "Extract Image Data": {
      "main": [[{ "node": "Wait (Rate Limit)", "type": "main", "index": 0 }]]
    },
    "Wait (Rate Limit)": {
      "main": [[{ "node": "Loop Over Items", "type": "main", "index": 0 }]]
    },
    "Aggregate All Items": {
      "main": [[{ "node": "Build AnkiApp Deck", "type": "main", "index": 0 }]]
    },
    "Build AnkiApp Deck": {
      "main": [[{ "node": "Success Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "active": true
}
